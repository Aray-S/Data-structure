# Problem 1

设计并实现一个基于最小化堆的整型的优先级队列，即队列元素为整型，数值越小，优先级越高。这个类除了实现队列的基本操作外，还需要在类中实现下列功能：<br/>
(1) **int findMin(int x)**：找出优先级值大于等于指定元素x的最小元素，并返回它的下标（下标值从1开始）。例如，在练习7简答题6的二叉堆中找出大于9的最小元素。这个元素应该是12，12的下标为4，所以返回4。请查找优先级值大于等于指定元素的最小元素，并返回对应的下标值。<br/>
(2)**void decreaseKey(int i, int value)**：将第i个节点（i从1开始计数）的优先级值减少value。例如，在练习7简答题6的二叉堆中执行decreaseKey(4,7)，结果如图（7-21）所示。<br/>
(3)**(int* getArray())**：按下标顺序返回优先级队列中各元素的值。

**输入描述**<br/>
第1行输入要生成的优先级队列中的元素个数N，N为正整数。<br/>
第2行输入要生成的优先级队列中的各个元素，元素为int类型，各元素以空格分隔。<br/>
第3行输入一个值，值为int类型，对应执行findMin()函数传递的参数x。且x的取值保证了队列元素中一定存在大于等于x的元素。<br/>
第4行输入一个值，值为int类型，且小于等于x，作为执行decreaseKey()时的参数value，其参数i取值于第三行findMin(x)的取值。

**输出描述**<br/>
输出共3行。<br/>
第1行输出执行decreaseKey()前的优先级队列按下标顺序输出的各元素的值，队列各值之间以空格分隔。<br/>
第2行输出执行decreaseKey()后的优先级队列按下标顺序输出的各元素的值，队列各值之间以空格分隔。<br/>
第3行输出执行decreaseKey()后的优先级队列按deQueue()顺序得到的值。

**输入举例**<br/>
16<br/>
12 17 8 6 7 15 18 37 18 24 3 26 33 23 21 14<br/>
11<br/>
8

**输出举例**<br/>
3 6 8 12 7 15 18 14 18 24 17 26 33 23 21 37<br/>
3 4 8 6 7 15 18 14 18 24 17 26 33 23 21 37<br/>
3 4 6 7 8 14 15 17 18 18 21 23 24 26 33 37

# Problem 2

最少背包问题：假设有许多盒子，每个盒子的容量为C。有N个物品，它们有着各自的重量。目的是用尽可能少的盒子放入所有的物品，且任何盒子的重量不能超过它的容量。请利用优先级队列来设计算法输出所需要的尽可能少的盒子数。

**输入描述**<br/>
第1行输入物品的个数N，N为正整数int类型。<br/>
第2行输入每个物品的重量，物品重量均大于0，且为正整数int类型，各重量之间以空格分隔。<br/>
第3行输入每个盒子能保存的最大重量C，C为正整数int类型，且C的值大于第二行输入的每一个物品的重量。<br/>

**输出描述**<br/>
输出共1行，输出利用算法得到的需要尽可能少的盒子的数目。

**输入举例**<br/>
4<br/>
4 4 6 6<br/>
10

**输出举例**<br/>
2
